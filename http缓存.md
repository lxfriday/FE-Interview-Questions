# HTTP 缓存

## 使用目的
缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以**降低资源的重复加载提高网页的整体加载速度**

## 分类
强缓存和协商缓存（对比缓存）

## 优先级
强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。
两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。

## 强缓存（Expires/Cache-Control）
强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据

### Expires 
值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。但它属于 HTTP 1.0，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。

### Cache-Control
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
- private:             客户端可以缓存
- public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
- max-age=xxx:         缓存的内容将在 xxx 秒后失效
- no-cache:            需要使用对比缓存来验证缓存数据（后面介绍）
- no-store:            所有内容都不会缓存，强制缓存，对比缓存都不会触发

## 对比缓存（Etag  /  If-None-Match 和 Last-Modified  /  If-Modified-Since）
比较判断是否可以使用缓存。

浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

### Etag / If-None-Match
Etag 服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

If-None-Match 再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。


## 流程图
![](http://qiniu1.lxfriday.xyz/WaterM/cbb619e3-49d1-4a2a-8603-292747aa0aba_632130-20170210141453338-1263276228.png)

## 用户操作对缓存的影响

![](http://qiniu1.lxfriday.xyz/WaterM/826a3be5-72c4-458c-80c3-567cb756c878_bVS1aN.png)

## 参考资料
- [彻底弄懂HTTP缓存机制及原理](https://www.cnblogs.com/chenqf/p/6386163.html)
- [缓存](http://blog.poetries.top/FE-Interview-Questions/advance/#_2-%E7%BC%93%E5%AD%98)


